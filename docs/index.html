<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mapterhorn Martin</title>
<script src="https://unpkg.com/maplibre-gl@5.6.1/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/maplibre-contour@0.1.0/dist/index.min.js"></script>
<link href="https://unpkg.com/maplibre-gl@5.6.1/dist/maplibre-gl.css" rel="stylesheet" />
<!-- Fallback libraries for environments where CDNs are blocked -->
<script src="lib/maplibre-gl-mock.js"></script>
<script src="lib/maplibre-contour-mock.js"></script>
<link href="lib/maplibre-gl-mock.css" rel="stylesheet" />
<script>
  // The fallback libraries are now always loaded.
  // If CDN libraries loaded successfully, they will override the mocks.
  // If CDN libraries failed, the mocks will be used instead.
  console.log('Fallback libraries loaded as backup');
</script>
<link rel="stylesheet" href="style.css">
</head>
<body>
<div id="map"></div>

<div id="terrain-controls">
  <h4>⛰️ Mapterhorn Martin</h4>
  
  <label>
    <input type="checkbox" id="contours" checked> Contour Lines
  </label>
  <div style="margin-left: 20px; font-size: 11px; color: #999;">
    Note: Contours use Mapterhorn data only
  </div>
  
  <label>
    <input type="checkbox" id="terrain" checked> Terrain (3D)
  </label>
  
  <label>
    <input type="checkbox" id="hillshade" checked> Hillshade Effects
  </label>
  
  <label>
    Terrain Source:
    <select id="terrain-source">
      <option value="mapterhorn">Mapterhorn (Terrarium)</option>
      <option value="gel">Gel (Mapbox)</option>
    </select>
  </label>
</div>

<div id="properties-panel">
  <button id="close-panel">&times;</button>
  <h3>Feature Properties</h3>
  <div id="properties-content"></div>
</div>

<script>
// Initialize maplibre-contour DemSource with Mapterhorn terrain tiles
var demSource = new mlcontour.DemSource({
  url: "https://tunnel.optgeo.org/martin/mapterhorn/{z}/{x}/{y}",
  encoding: "terrarium",
  maxzoom: 12,
  worker: true, // offload contour computation to web worker
  cacheSize: 100,
  timeoutMs: 10000
});

// Register the contour protocol with maplibre
demSource.setupMaplibre(maplibregl);

// Load the base style from external JSON file
fetch('style.json')
.then(response => response.json())
.then(baseStyle => {
    // Add the dynamic contours source
    baseStyle.sources.contours = {
        "type": "vector",
        "tiles": [
            demSource.contourProtocolUrl({
                // Keep in meters (multiplier: 1)
                multiplier: 1,
                thresholds: {
                    // zoom: [minor, major] intervals in meters
                    10: [100, 500],
                    11: [50, 250],
                    12: [25, 100],
                    13: [10, 50],
                    14: [5, 25],
                    15: [2, 10]
                },
                elevationKey: "ele",
                levelKey: "level",
                contourLayer: "contours"
            })
        ],
        "maxzoom": 15
    };

    // Add contour layers
    const contourLinesLayer = {
        "id": "contour-lines",
        "type": "line",
        "source": "contours",
        "source-layer": "contours",
        "paint": {
            "line-color": [
                "case",
                [">", ["get", "level"], 0],
                "#B8860B", // major contours (softer brown)
                "#DEB887"  // minor contours (lighter beige)
            ],
            "line-width": [
                "interpolate",
                ["linear"],
                ["zoom"],
                10, ["case", [">", ["get", "level"], 0], 1.2, 0.6],
                15, ["case", [">", ["get", "level"], 0], 2.0, 1.0]
            ],
            "line-opacity": 0.6
        },
        "layout": {
            "line-join": "miter",
            "line-cap": "butt"
        }
    };

    const contourLabelsLayer = {
        "id": "contour-labels",
        "type": "symbol",
        "source": "contours",
        "source-layer": "contours",
        "filter": [">", ["get", "level"], 0], // only label major contours
        "paint": {
            "text-color": "#5D4E37",
            "text-halo-color": "rgba(255,255,255,0.8)",
            "text-halo-width": 2
        },
        "layout": {
            "symbol-placement": "line",
            "text-anchor": "center",
            "text-size": [
                "interpolate",
                ["linear"],
                ["zoom"],
                10, 10,
                15, 14
            ],
            "text-field": [
                "concat",
                ["number-format", ["get", "ele"], {}],
                "m"
            ],
            "text-font": ["Noto Sans Bold"],
            "text-max-angle": 30,
            "text-rotation-alignment": "map"
        }
    };

    // Insert contour layers after landcover layer
    const landcoverIndex = baseStyle.layers.findIndex(layer => layer.id === 'landcover');
    if (landcoverIndex !== -1) {
        baseStyle.layers.splice(landcoverIndex + 1, 0, contourLinesLayer, contourLabelsLayer);
    } else {
        // Fallback: add at the beginning
        baseStyle.layers.unshift(contourLinesLayer, contourLabelsLayer);
    }

    // Initialize map with the complete style
    initializeMap(baseStyle);
})
.catch(error => {
    console.error('Error loading style.json:', error);
    // Fallback to a basic style if loading fails
    const fallbackStyle = {
        "version": 8,
        "sources": {},
        "layers": []
    };
    initializeMap(fallbackStyle);
});

function initializeMap(style) {
    // Initialize map (make it global so event handlers can access it)
    window.map = new maplibregl.Map({
        container: 'map',
        style: style,
        center: [7.7461, 46.0382], // Matterhorn coordinates
        zoom: 12,
        pitch: 60,
        bearing: 0,
        antialias: true,
        hash: true
    });

    // Add controls
    window.map.addControl(new maplibregl.NavigationControl({
        visualizePitch: true,
        showZoom: true,
        showCompass: true
    }));

    window.map.addControl(new maplibregl.GlobeControl());

    // Properties panel
    let propertiesPanel = document.getElementById('properties-panel');
    let propertiesContent = document.getElementById('properties-content');
    let closePanel = document.getElementById('close-panel');

    closePanel.addEventListener('click', () => {
        propertiesPanel.style.display = 'none';
    });

    window.map.on('click', (e) => {
        const features = window.map.queryRenderedFeatures(e.point);
        
        if (features.length > 0) {
            propertiesContent.innerHTML = '';
            
            features.forEach((feature, index) => {
                const featureDiv = document.createElement('div');
                featureDiv.className = 'feature-item';
                
                const headerDiv = document.createElement('div');
                headerDiv.className = 'feature-header';
                headerDiv.textContent = `${feature.sourceLayer || 'Feature'} (${feature.geometry.type})`;
                headerDiv.onclick = () => {
                    const props = featureDiv.querySelector('.feature-properties');
                    props.classList.toggle('collapsed');
                };
                
                const propsDiv = document.createElement('div');
                propsDiv.className = 'feature-properties';
                
                if (feature.properties && Object.keys(feature.properties).length > 0) {
                    propsDiv.textContent = JSON.stringify(feature.properties, null, 2);
                } else {
                    propsDiv.textContent = 'No properties';
                }
                
                featureDiv.appendChild(headerDiv);
                featureDiv.appendChild(propsDiv);
                propertiesContent.appendChild(featureDiv);
            });
            
            propertiesPanel.style.display = 'block';
        } else {
            propertiesPanel.style.display = 'none';
        }
    });

    // Enable terrain when map loads
    window.map.on('load', () => {
        window.map.setTerrain({
            source: 'mapterhorn-terrain',
            exaggeration: 1.0
        });
        
        console.log('Mapterhorn Terrain Visualization with Contour Lines');
        console.log('Data source: https://tunnel.optgeo.org/martin/mapterhorn');
        console.log('Contour generation: maplibre-contour library');
        console.log('Encoding: Terrarium format');
        console.log('Units: Meters');
    });

    // Control functionality
    document.getElementById('contours').addEventListener('change', function() {
      const visibility = this.checked ? 'visible' : 'none';
      try {
        // Check if map is loaded and contour layers exist before trying to set their visibility
        if (!window.map || !window.map.isStyleLoaded()) {
          console.warn('Map not ready for contour toggle');
          return;
        }
        
        const style = window.map.getStyle();
        if (!style || !style.layers) {
          console.warn('Map style not available for contour toggle');
          return;
        }
        
        // Check if contour layers exist in the current style
        const hasContourLines = style.layers.some(layer => layer.id === 'contour-lines');
        const hasContourLabels = style.layers.some(layer => layer.id === 'contour-labels');
        
        if (hasContourLines) {
          window.map.setLayoutProperty('contour-lines', 'visibility', visibility);
        }
        if (hasContourLabels) {
          window.map.setLayoutProperty('contour-labels', 'visibility', visibility);
        }
      } catch (error) {
        console.error('Error toggling contours:', error);
      }
    });

    document.getElementById('terrain').addEventListener('change', function() {
        const enabled = this.checked;
        if (enabled) {
            window.map.setTerrain({
                source: 'mapterhorn-terrain',
                exaggeration: 1.0
            });
        } else {
            window.map.setTerrain(null);
        }
    });

    document.getElementById('terrain-source').addEventListener('change', function() {
        const source = this.value;
        const terrainSource = source === 'gel' ? 'gel-terrain' : 'mapterhorn-terrain';
        const hillshadeSource = source === 'gel' ? 'gel-hillshade' : 'mapterhorn-hillshade';
        
        // Update terrain source
        window.map.setTerrain({
            source: terrainSource,
            exaggeration: 1.0
        });
        
        // Update hillshade source if it exists
        try {
            if (window.map.getLayer('hillshade')) {
                window.map.removeLayer('hillshade');
            }
            if (window.map.getSource('hillshade')) {
                window.map.removeSource('hillshade');
            }
            
            // Re-add hillshade with new dedicated source
            window.map.addLayer({
                "id": "hillshade",
                "type": "hillshade",
                "source": hillshadeSource,
                "paint": {
                    "hillshade-shadow-color": "#473B24",
                    "hillshade-illumination-direction": 315,
                    "hillshade-exaggeration": 0.8
                }
            }, 'roads_tunnels_other_casing');
        } catch (error) {
            console.warn('Could not update hillshade:', error);
        }
    });

    document.getElementById('hillshade').addEventListener('change', function() {
        const visibility = this.checked ? 'visible' : 'none';
        window.map.setLayoutProperty('hillshade', 'visibility', visibility);
    });
    // Log terrain configuration
    console.log('Mapterhorn Terrain Visualization initialized');
    console.log('Data source: https://tunnel.optgeo.org/martin/mapterhorn');
    console.log('Features: 3D terrain, hillshade, contour lines, interactive controls');
}


</script>
</body>
</html>